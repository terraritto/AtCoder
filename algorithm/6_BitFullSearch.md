# BitFullSearch(bit全探索)
bit演算を利用して全探索をしていく方法  
これにより部分集合を全パターン列挙したりできるらしい.....?  
とりあえず例を見てみる
~~~cpp
int main() {
    int n = 3;

    // {0, 1, ..., n-1} の部分集合の全探索
    for (int bit = 0; bit < (1<<n); ++bit) {
        vector<int> S;
        for (int i = 0; i < n; ++i) {
            if (bit & (1<<i)) { // i が bit に入るかどうか
                S.push_back(i);
            }
        }

        cout << bit << ": {";
        for (int i = 0; i < (int)S.size(); ++i) {
            cout << S[i] << " ";
        }
        cout << "}" << endl;
    }
}
~~~
n=3として考えよう、まずはここ
~~~cpp
 for (int bit = 0; bit < (1<<n); ++bit) {
~~~
`<<`は左シフトだ、1をシフトするので`2^n(n>=0)`を繰り返すということがわかる。  
`2^n`ってなんだ？って言われるとすぐ思いつくのはこの場合は全ての組み合わせである。  
今回は存在するかしないかの2パターンなので,`0,1,2`の場合`2*2*2=8=2^3`となる。これを表していると思えばよい。  
```cpp
for (int i = 0; i < n; ++i) {
    if (bit & (1<<i)) { // i が bit に入るかどうか
        S.push_back(i);
    }
}
```
次はここ  
n=3なので、`1<<i`は`0001,0010,0100`となる。  
これに対して`0000,0001,0010, ... , 0111`のすべてに対して`&`判定、つまりは`i`番目が立っているかどうかを判定する。  
`i`っていうのは部分集合の要素を表しているので、8つの立っているところさえ列挙できれば部分集合となる。  
これがbit全探索の考え方である。

練習問題  
[たくさんの数式](https://atcoder.jp/contests/arc061/tasks/arc061_a)