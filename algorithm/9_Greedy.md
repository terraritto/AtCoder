# Greedy(貪欲法)
1つのルールに従って、貪欲的に「その場での最善」を選択することを繰り返していくというアルゴリズム設計技法。  
典型的な問題を見ていこう.  
1. 硬貨の問題  
1,5,10,50,100,500の硬貨を指定枚数持ってる。  
指定の金額を払うのにコインは最低何枚必要か?  
これにおいての方針は実にシンプル
* 大きな額の硬貨から優先的に使う.
  
  つまり、「大きな額の硬貨から使う」というルールから最善の「最低枚数」を調べていくのである。

例
~~~cpp
const int V[6] = {1,5,10,50,100,500};

//input
int C[6];
int A;

void solve()
{
    int ans = 0;

    for(int i = 5; i >= 0;--i)
    {
        int t = min(A / V[i],C[i]); //コインiを使う枚数
        A -= t * V[i];
        ans += t;    
    }

    printf("%d\n",ans);
} 
~~~
【演習】
JOI 2007 A  
2. 区間スケジューリング

nこの仕事についてs_iに仕事が始まりt_iに終わる。  
仕事に三挿したらその仕事の初めから終わりまで参加する必要がある。  
どうすれば一番仕事が取れる?

* 選べる仕事の中で一番速い奴  
これはダメ、もしも一番速いものがめちゃくちゃ長かったら成り立たない
* 選べる仕事の中で時間が短いもの  
これもダメ、二つの仕事がうまくいれられるけど、その間にそれよりも短い時間で終わるものが存在する場合に破綻する  
* 選べる仕事の中で、その仕事を選んだときに選べなくあるほかの仕事が最も少ないもの  
重なりが4~5と膨らんできた場合にアウトなものが出てくる可能性がある。  
 選べる仕事の中で終了時間が一番速いもの  
これが正解  
~~~cpp
int n,s[max],t[max];

pair<int,int> itv[max];

void solve()
{
    //pairは辞書順で比較される
    //終了時間の速い順にするため T->firtst S->second となる
    for(int i = 0;i<N;i++)
    {
        itv[i].first = t[i];
        itv[i].second = s[i];
    }
    sort(itv,itv+n);

    //t最後に選んだ仕事の終了時間
    int ans = 0; t = 0;
    for(int i = 0; i < N; i++)
    {
        if(t < itv[i].second) 
        //startが前のendよりも大きい->次に遷移してOK
        {
            ans++;
            t = itv[i].first; //endが入る
        }
    }
}
~~~
[演習]  
KUPC 2015 A  
最初に出てきた"kyoto","tokyo"をカウントしていけばよい。  
くっつけられることを考えてないので、見つけたところより前は全部吹き飛ばすなどの措置が必要。

3. 辞書順最初の問題
sの文字列からtの文字列を作る。操作は以下のものとなる。
* sの先頭を削除し、tの末尾に追加
* sの末尾を削除し、tの末尾に追加  
辞書順比較で出来るだけ小さくなるようにtを作れ。

今回の指針
* sの先頭と末尾の、より小さい方の文字をtの末尾に付け加える
ただしこれだけだと先頭と末尾の文字が同じ場合がアウト  
そのため,
* SとSを反転させた文字列S'を辞書式比較しsが小さい場合は先頭,s'が小さい場合は末尾に追加を行う。

~~~cpp
int n;
char s[max+1];

void solve()
{
    int a = 0, b = n-1;

    while(a <= b)
    {
        bool left = false;
        for(int i = 0;a + i <= b; i++)
        {
            if(s[a+i] < s[b-i])
            {
                left = true;
                break;
            }
            else if(s[a+i] > s[b-i])
            {
                left = false;
                break;
            }
        }

        if(left) { putchar(S[a++]);}
        else { putchar(S[b--]);}

        putchar(`\n`);
    }
}
~~~
【演習】  
ABC 076 C  
辞書式順序なので、もしも埋まらなかったところはaを埋め込めばよい。  
埋められるところに対するものを全て用意して、それをsortすればそれで終わり。